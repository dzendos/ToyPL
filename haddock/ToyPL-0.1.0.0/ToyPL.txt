-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package ToyPL
@version 0.1.0.0


-- | The abstract syntax of language ToyPL.
module ToyPL.Abs
data ProgramState
ProgramState :: Integer -> Integer -> Integer -> String -> [(Variable, Integer)] -> ProgramState

-- | Represents a label that means that program is terminated.
[finishLabel] :: ProgramState -> Integer

-- | Position of the program execution (position of command that should be
--   executed next).
[execPosition] :: ProgramState -> Integer

-- | Code-state of the program -1, 0, 1 for running, exited successfully,
--   unsuccessfully programs respectively.
[execCode] :: ProgramState -> Integer

-- | Message after program has finished its execution.
[exitMessage] :: ProgramState -> String

-- | Map of variables and their values.
[variables] :: ProgramState -> [(Variable, Integer)]
data Program
PSeq :: Program -> Program -> Program
PIf :: Condition -> Program -> Program -> Program
PAssign :: Variable -> Exp -> Program
PWhile :: Condition -> Program -> Program
data Condition
COr :: Condition -> Condition -> Condition
CAnd :: Condition -> Condition -> Condition
CNot :: Condition -> Condition
CEquals :: Exp -> Exp -> Condition
CLessThan :: Exp -> Exp -> Condition
CBiggerThan :: Exp -> Exp -> Condition
CLessOrEqual :: Exp -> Exp -> Condition
CBiggerOrEqual :: Exp -> Exp -> Condition
data Exp
EAdd :: Exp -> Exp -> Exp
ESub :: Exp -> Exp -> Exp
EMul :: Exp -> Exp -> Exp
EDiv :: Exp -> Exp -> Exp
EFact :: Exp -> Exp
EInt :: Integer -> Exp
EVar :: Variable -> Exp
data Variable
Variable :: Ident -> Variable
data Command
VMProg :: Command -> Command -> Command
VMAssignment :: Label -> Variable -> Exp -> Label -> Command
VMBranching :: Label -> Condition -> Label -> Label -> Command
data Label
VMLabel :: Integer -> Label
newtype Ident
Ident :: String -> Ident
instance GHC.Read.Read ToyPL.Abs.Label
instance GHC.Classes.Ord ToyPL.Abs.Label
instance GHC.Classes.Eq ToyPL.Abs.Label
instance Data.String.IsString ToyPL.Abs.Ident
instance GHC.Read.Read ToyPL.Abs.Ident
instance GHC.Classes.Ord ToyPL.Abs.Ident
instance GHC.Classes.Eq ToyPL.Abs.Ident
instance GHC.Read.Read ToyPL.Abs.Variable
instance GHC.Classes.Ord ToyPL.Abs.Variable
instance GHC.Classes.Eq ToyPL.Abs.Variable
instance GHC.Read.Read ToyPL.Abs.Exp
instance GHC.Classes.Ord ToyPL.Abs.Exp
instance GHC.Classes.Eq ToyPL.Abs.Exp
instance GHC.Read.Read ToyPL.Abs.Condition
instance GHC.Classes.Ord ToyPL.Abs.Condition
instance GHC.Classes.Eq ToyPL.Abs.Condition
instance GHC.Read.Read ToyPL.Abs.Command
instance GHC.Classes.Ord ToyPL.Abs.Command
instance GHC.Classes.Eq ToyPL.Abs.Command
instance GHC.Read.Read ToyPL.Abs.Program
instance GHC.Show.Show ToyPL.Abs.Program
instance GHC.Classes.Ord ToyPL.Abs.Program
instance GHC.Classes.Eq ToyPL.Abs.Program
instance GHC.Show.Show ToyPL.Abs.ProgramState
instance GHC.Show.Show ToyPL.Abs.Command
instance GHC.Show.Show ToyPL.Abs.Condition
instance GHC.Show.Show ToyPL.Abs.Exp
instance GHC.Show.Show ToyPL.Abs.Variable
instance GHC.Show.Show ToyPL.Abs.Ident
instance GHC.Show.Show ToyPL.Abs.Label


-- | BNF Converter: Error Monad.
--   
--   Module for backwards compatibility.
--   
--   The generated parser now uses <tt><a>Either</a> String</tt> as error
--   monad. This module defines a type synonym <a>Err</a> and pattern
--   synonyms <a>Bad</a> and <a>Ok</a> for <a>Left</a> and <a>Right</a>.
module ToyPL.ErrM

-- | Error monad with <a>String</a> error messages.
type Err = Either String
pattern Bad :: a -> Either a b
pattern Ok :: forall {a} {b}. b -> Either a b
instance Control.Monad.Fail.MonadFail ToyPL.ErrM.Err
instance GHC.Base.Alternative ToyPL.ErrM.Err
instance GHC.Base.MonadPlus ToyPL.ErrM.Err

module ToyPL.Lex

-- | Create a token with position.
tok :: (String -> Tok) -> Posn -> String -> Token

-- | Token without position.
data Tok

-- | Reserved word or symbol.
TK :: {-# UNPACK #-} !TokSymbol -> Tok

-- | String literal.
TL :: !String -> Tok

-- | Integer literal.
TI :: !String -> Tok

-- | Identifier.
TV :: !String -> Tok

-- | Float literal.
TD :: !String -> Tok

-- | Character literal.
TC :: !String -> Tok

-- | Smart constructor for <a>Tok</a> for the sake of backwards
--   compatibility.
pattern TS :: String -> Int -> Tok

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol
TokSymbol :: String -> !Int -> TokSymbol

-- | Keyword or symbol text.
[tsText] :: TokSymbol -> String

-- | Unique ID.
[tsID] :: TokSymbol -> !Int

-- | Token with position.
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token

-- | Pretty print a position.
printPosn :: Posn -> String

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String

-- | Get the position of a token.
tokenPosn :: Token -> Posn

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)

-- | Convert a token to its text.
tokenText :: Token -> String

-- | Convert a token to a string.
prToken :: Token -> String

-- | Finite map from text to token organized as binary search tree.
data BTree

-- | Nil (leaf).
N :: BTree

-- | Binary node.
B :: String -> Tok -> BTree -> BTree -> BTree

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok

-- | The keywords and symbols of the language organized as binary search
--   tree.
resWords :: BTree

-- | Unquote string literal.
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
alex_action_1 :: Posn -> String -> Token
alex_action_2 :: Posn -> String -> Token
alex_action_3 :: Posn -> String -> Token
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (Posn -> String -> Token)
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: AlexInput -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> AlexInput -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t -> t -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, AlexInput)
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user
instance GHC.Show.Show ToyPL.Lex.TokSymbol
instance GHC.Classes.Ord ToyPL.Lex.Tok
instance GHC.Show.Show ToyPL.Lex.Tok
instance GHC.Classes.Eq ToyPL.Lex.Tok
instance GHC.Show.Show ToyPL.Lex.BTree
instance GHC.Classes.Ord ToyPL.Lex.Posn
instance GHC.Show.Show ToyPL.Lex.Posn
instance GHC.Classes.Eq ToyPL.Lex.Posn
instance GHC.Classes.Ord ToyPL.Lex.Token
instance GHC.Show.Show ToyPL.Lex.Token
instance GHC.Classes.Eq ToyPL.Lex.Token
instance GHC.Classes.Eq ToyPL.Lex.TokSymbol
instance GHC.Classes.Ord ToyPL.Lex.TokSymbol

module ToyPL.Par
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
pProgram :: [Token] -> Err Program
pProgram1 :: [Token] -> Err Program
pCondition :: [Token] -> Err Condition
pCondition1 :: [Token] -> Err Condition
pCondition2 :: [Token] -> Err Condition
pCondition3 :: [Token] -> Err Condition
pExp :: [Token] -> Err Exp
pExp1 :: [Token] -> Err Exp
pExp2 :: [Token] -> Err Exp
pExp3 :: [Token] -> Err Exp
pVariable :: [Token] -> Err Variable
pCommand :: [Token] -> Err Command
pLabel :: [Token] -> Err Label


-- | Pretty-printer for Print.
module ToyPL.Print

-- | The top-level printing method.
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
render :: Doc -> String
parenth :: Doc -> Doc
concatS :: [ShowS] -> ShowS
concatD :: [Doc] -> Doc
replicateS :: Int -> ShowS -> ShowS

-- | The printer class does the job.
class Print a
prt :: Print a => Int -> a -> Doc
printString :: String -> Doc
mkEsc :: Char -> Char -> ShowS
prPrec :: Int -> Int -> Doc -> Doc
instance ToyPL.Print.Print a => ToyPL.Print.Print [a]
instance ToyPL.Print.Print GHC.Types.Char
instance ToyPL.Print.Print GHC.Base.String
instance ToyPL.Print.Print GHC.Num.Integer.Integer
instance ToyPL.Print.Print GHC.Types.Double
instance ToyPL.Print.Print ToyPL.Abs.Ident
instance ToyPL.Print.Print ToyPL.Abs.Program
instance ToyPL.Print.Print ToyPL.Abs.Condition
instance ToyPL.Print.Print ToyPL.Abs.Exp
instance ToyPL.Print.Print ToyPL.Abs.Variable
instance ToyPL.Print.Print ToyPL.Abs.Command
instance ToyPL.Print.Print ToyPL.Abs.Label

module ToyPL.Trans

-- | transs given program into sequens of commands.
transProgram :: Program -> (Integer, [Command])

-- | Recursive translation of program into sequence of commands with
--   labels.
transProgramToVM :: Program -> Integer -> (Integer, [Command])

-- | transs variable by given identifier into string.
transVariable :: Variable -> String

-- | transs identifier into string.
transIdent :: Ident -> String

-- | transs a label into Integer.
transLabel :: Label -> Integer

module ToyPL.Eval

-- | Evaluetes the value of the expression if possible.
evalExp :: ProgramState -> Exp -> Maybe Integer

-- | Evaluates the condition if possible.
evalCondition :: ProgramState -> Condition -> Maybe Bool

-- | Executes command.
evalCommand :: ProgramState -> Command -> ProgramState
checkState :: Eq a => Maybe a -> Integer -> ProgramState -> ProgramState
apply :: (a -> a -> b) -> Maybe a -> Maybe a -> Maybe b

module ToyPL
getCommand :: ProgramState -> [Command] -> Maybe Command

-- | Processes given command.
processCommands :: String -> ProgramState -> [Command] -> ProgramState

-- | Gets command from the User and processes it.
programRunner :: ProgramState -> [Command] -> IO ()
translateInput :: String -> Either String [String]
runWithInput :: String -> IO ()

-- | Runs the compiler.
run :: IO ()

-- | Tries to translate given program s.
tplProgram :: String -> (Integer, [Command])

-- | Returns a list of commands that can be printed on the screen.
commandsToStrings :: [Command] -> [String]
